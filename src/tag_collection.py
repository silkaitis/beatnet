import sys, curses

import psycopg2 as pg2
import cPickle as pickle
import xmltodict

from beatport_api import beatport
from time import time, sleep

class collectionlister(object):
    '''
    Class to build track list from M3U8 generated by Rekordbox
    '''

    def __init__(self, fname):
        self.filename = fname

    def read_file(self):
        '''
        Read lines of file and store
        '''
        self.lines = []
        string = ''
        with open(self.filename, 'r') as f:

            for line in f.read():

                string += line

                if line == '\n':
                    self.lines.append(string)
                    string = ''

        return

    def read_tracks(self):
        '''
        Transform file into better format
        '''
        soln = []

        for track in self.lines:
            if track[0:7] == '#EXTINF':
                pos = track.find(',') + 1
                soln.append(track[pos:])

        self.tracks = self.strip_return(soln)

        return

    def strip_return(self, tracks):
        '''
        Remove the carriage return from last track
        '''

        tracks = [track.replace('\r\n','') for track in tracks]

        return(tracks)

    def build(self):
        '''
        Build track list and return list
        '''
        self.collection = []

        self.read_file()

        self.read_tracks()

        for track in self.tracks:
            trk = track.split(' - ')
            self.collection.append(trk)

        return

class collectiontagger(object):

    def __init__(self, beatport, my_collection):
        self.bprt = beatport
        self.my_col = my_collection

    def sql_connect(self):
        '''
        Connect to Postgres database with Beatport data
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()
        return(conn, cur)


    def _setup_progress_bar(self, num):
        '''
        Setup counter for long search processes
        '''
        curses.initscr()
        curses.curs_set(0)

        sentence = 'Track {} of {} complete.' \
                     .format(' '*len(str(num)), str(num))

        sys.stdout.write(sentence)
        sys.stdout.flush()

        sys.stdout.write('\b' * (len(sentence) - 6))

        return

    def _update_progress_bar(self, curr):
        '''
        Update counter with current iteration
        '''
        pg = str(curr)

        sys.stdout.write(pg)
        sys.stdout.flush()
        sys.stdout.write('\b' * len(pg))

        return

    def _escape_progress_bar(self):
        '''
        Properly exit the counter
        '''
        sys.stdout.write('\n')
        curses.curs_set(1)
        curses.reset_shell_mode()
        return

    def _convert_raw_artist(self, artists):
        '''
        Split artist string into individuals or producer pair

        INPUT
            artists - artist(s) name(s) for a track, STR
        OUTPUT
            soln - list of each artist in string, LIST
        '''

        artists = artists.replace(', ','*') \
                         .replace(' feat ','*') \
                         .replace(' feat. ','*') \
                         .replace(' ft ','*') \
                         .replace(' ft. ','*') \
                         .lower() \
                         .split('*')
        soln = []
        for a in artists:
            soln.append(a)

            if ' & ' in a:
                soln.extend(a.split(' & '))

        return(soln)

    def _artist_set(self, tracks):
        '''
        Clean up artist names and build set

        INPUT
            tracks - tracks in collection with
                                each track as list [artist, track], LIST
        OUTPUT
            artists - unique artists in collection, SET
        '''
        artists = set()

        for track in tracks:
            track = self._convert_raw_artist(track[0])

            for art in track:
                artists.add(art)

        return(artists)

    def _beatport_artists(self):
        '''
        Fetch all artists and ids from Postgres

        INPUT
            None
        OUTPUT
            dict - dictionary of artist name (key) and id (val), DICT
        '''
        conn, cur = self.sql_connect()

        cur.execute('SELECT * FROM bprt_artist;')
        data = cur.fetchall()

        cur.close()
        conn.close()

        return({val[1] : val[0] for val in data})

    def _recode_tracks(self):
        '''
        Recode collection into artist id and track name

        INPUT

        OUTPUT
            r_tracks - tracks in collection with
                                each track as list [artist_id, track], LIST
        '''
        r_tracks = []
        for trk in self.my_col:
            arts = self._convert_raw_artist(trk[0])

            for a in arts:
                if self.tag_art.has_key(a):
                    r_tracks.append([self.tag_art[a], trk[1]])

        return(r_tracks)

    def tag_artists(self):
        '''
        Match collection artist to Beatport artist ID

        INPUT
            None
        OUTPUT
            None
        '''
        my_art = self._artist_set(self.my_col)
        bprt_art = self._beatport_artists()

        self.tag_art = {}
        for val in my_art:
            if bprt_art.has_key(val):
                self.tag_art[val] = bprt_art[val]

        self.artist_tag()
        return

    def artist_tag(self):
        '''
        Reverse artist dictionary {id : name}
        '''
        self.art_tag = {val : key for key, val in self.tag_art.iteritems()}

        return

    def tag_tracks(self):
        '''
        Match collection tracks to Beatport track ID
        '''
        self.tag_trk = {}
        self.no_trk = []

        trks = self._recode_tracks()

        self._setup_progress_bar(len(trks))

        for i, trk in enumerate(trks):

            self._update_progress_bar(i)

            qry = self.bprt.tracks_w_track_terms_artist_id(trk[1], trk[0])

            found = 0
            i = 0

            while (found == 0) and (i < len(qry)):
            #A track may appear more than once due to various reasons such
            #re-release or year-end collection from record label.
            #Unfortunately, Beatport assigns a new track id each time a
            #track appears even if it is an identical track.
                title = trk[1].decode('utf8')
                len_title = len(title) / 2
                if (title[:len_title] in qry[i]['name']) or \
                   (title[:len_title] in qry[i]['title']):

                    self.tag_trk[qry[i]['id']] = (trk[0], qry[i]['name'], trk[1])
                    found = 1

                i += 1

        self._escape_progress_bar()

        return

    def track_playcount(self, fname):
        '''
        Read XML file and match track ID with collection play count and
        date added to collection
        '''
        self.play_count = {}

        with open(fname, 'r') as fd:
            doc = xmltodict.parse(fd.read())

        self._setup_progress_bar(len(self.tag_trk))

        i = 1

        for key, val in self.tag_trk.iteritems():

            self._update_progress_bar(i)

            for track in doc['DJ_PLAYLISTS']['COLLECTION']['TRACK']:

                if (val[2].decode('utf8') in track['@Name']) and \
                   (self.art_tag[val[0]] in track['@Artist'].lower()):

                    self.play_count[key] = (track['@PlayCount'],
                                            track['@DateAdded'])

            i += 1

        self._escape_progress_bar()
        return


    def save_artists(self):
        '''
        Store list of artists from collection in Postgres
        '''
        conn, cur = self.sql_connect()

        cur.execute('DROP TABLE IF EXISTS my_artist')
        cur.execute('''CREATE TABLE my_artist (id INTEGER PRIMARY KEY)''')
        conn.commit()

        for key, val in self.tag_art.iteritems():
            cur.execute('INSERT INTO my_artist (id) VALUES (%s)', [val])

        conn.commit()

        cur.close()
        conn.close()
        return

    def save_tracks(self):
        '''
        Store list of artists from collection in Postgres
        '''
        conn, cur = self.sql_connect()

        cur.execute('DROP TABLE IF EXISTS my_tracks')
        cur.execute('''CREATE TABLE my_tracks (id INTEGER PRIMARY KEY,
                                               artist_id INTEGER,
                                               bprt_name TEXT,
                                               col_name TEXT)''')
        conn.commit()

        for key, val in self.tag_trk.iteritems():
            cur.execute('''INSERT INTO my_tracks (id,
                                                  artist_id,
                                                  bprt_name,
                                                  col_name)
                                                  VALUES (%s, %s, %s, %s);''',
                                                  (key, val[0], val[1], val[2]))

        conn.commit()

        cur.close()
        conn.close()
        return

    def save_playcount(self):
        '''
        Store play count and date added
        for each track from collection in Postgres
        '''
        conn, cur = self.sql_connect()

        cur.execute('DROP TABLE IF EXISTS my_playcount')
        cur.execute('''CREATE TABLE my_playcount (id INTEGER PRIMARY KEY,
                                                  playcount INTEGER,
                                                  DateAdded DATE)''')
        conn.commit()

        for key, val in self.play_count.iteritems():
            cur.execute('''INSERT INTO my_playcount (id,
                                                     playcount,
                                                     DateAdded)
                                                  VALUES (%s, %s, %s);''',
                                                  (key, val[0], val[1]))

        conn.commit()

        cur.close()
        conn.close()
        return


if __name__ == '__main__':
    now = time()

    '''
    TO DO- Rekordbox playlist doesn't contain track details
    such as Date Added or Play Count. Rekordbox can export an XML file which
    contains that information. collectionlister should be refactored to use
    the XML so all track data can be harmonized at once instead of two passes.
    '''
    tracks = collectionlister('../data/my_collection.m3u8')
    tracks.build()

    bprt = beatport('/Users/danius/galvanize/API/mykeys.yaml')
    bprt.initialize()

    ritchey = collectiontagger(bprt, tracks.collection)
    ritchey.tag_artists()
    ritchey.save_artists()
    print('Collection Artists Saved')

    ritchey.tag_tracks()
    ritchey.save_tracks()
    print('Collection Tracks Saved')

    ritchey.track_playcount('/Users/danius/Documents/Github/beatnet/data/xml_collection_020817.xml')
    ritchey.save_playcount()
    print('Collection Metadata Saved')


    later = time()

    t = (later - now) * (1/60.)

    print('Collection tagging took {} minutes'.format(t))

import sys, curses

import psycopg2 as pg2
import cPickle as pickle
import xmltodict

from beatport_api import beatport
from time import time, sleep

class collectionlister(object):
    '''
    Class to build track list from M3U8 generated by Rekordbox
    '''

    def __init__(self, fname):
        self.filename = fname

    def read_file(self):
        '''
        Read lines of file and store
        '''
        self.lines = []
        string = ''
        with open(self.filename, 'r') as f:

            for line in f.read():

                string += line

                if line == '\n':
                    self.lines.append(string)
                    string = ''

        return

    def read_tracks(self):
        '''
        Transform file into better format
        '''
        soln = []

        for track in self.lines:
            if track[0:7] == '#EXTINF':
                pos = track.find(',') + 1
                soln.append(track[pos:])

        self.tracks = self.strip_return(soln)

        return

    def strip_return(self, tracks):
        '''
        Remove the carriage return from last track
        '''

        tracks = [track.replace('\r\n','') for track in tracks]

        return(tracks)

    def build(self):
        '''
        Build track list and return list
        '''
        self.collection = []

        self.read_file()

        self.read_tracks()

        for track in self.tracks:
            trk = track.split(' - ')
            self.collection.append(trk)

        return

class collectiontagger(object):

    def __init__(self, beatport, my_collection):
        self.bprt = beatport
        self.my_col = my_collection

    def _setup_progress_bar(self, num):
        curses.initscr()
        curses.curs_set(0)

        sentence = 'Track {} of {} complete.' \
                     .format(' '*len(str(num)), str(num))

        sys.stdout.write(sentence)
        sys.stdout.flush()

        sys.stdout.write('\b' * (len(sentence) - 6))

        return

    def _update_progress_bar(self, curr):
        pg = str(curr)

        sys.stdout.write(pg)
        sys.stdout.flush()
        sys.stdout.write('\b' * len(pg))

        return

    def _escape_progress_bar(self):
        sys.stdout.write('\n')
        curses.curs_set(1)
        curses.reset_shell_mode()
        return

    def _convert_raw_artist(self, artists):

        artists = artists.replace(', ','*') \
                         .replace(' feat ','*') \
                         .replace(' feat. ','*') \
                         .replace(' ft ','*') \
                         .replace(' ft. ','*') \
                         .lower() \
                         .split('*')
        soln = []
        for a in artists:
            soln.append(a)
            if ' & ' in a:
                soln.extend(a.split(' & '))

        return(soln)

    def _artist_set(self, tracks):
        '''
        Clean up artist names and build set
        '''
        artists = set()

        for track in tracks:

            track = self._convert_raw_artist(track[0])

            for art in track:

                artists.add(art)

        return(artists)

    def _beatport_artists(self):
        '''
        Fetch all artists and ids from Postgres
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()

        cur.execute('SELECT * FROM bprt_artist;')
        data = cur.fetchall()

        cur.close()
        conn.close()

        btprt_artist = {}
        for val in data:
            btprt_artist[val[1]] = val[0]

        return(btprt_artist)

    def tag_artists(self):
        '''
        Match collection artist to Beatport artist ID
        '''
        my_art = self._artist_set(self.my_col)
        bprt_art = self._beatport_artists()

        self.tag_art = {}
        for val in my_art:
            if bprt_art.has_key(val):
                self.tag_art[val] = bprt_art[val]

        self.artist_tag()
        return

    def artist_tag(self):
        '''
        Switch artist dictionary
        '''
        self.art_tag = {}
        for key, val in self.tag_art.iteritems():
            self.art_tag[val] = key

        return

    def _recode_tracks(self):
        '''
        Recode collection into artist id and track name
        '''
        r_tracks = []
        for trk in self.my_col:
            arts = self._convert_raw_artist(trk[0])

            for a in arts:
                if self.tag_art.has_key(a):
                    r_tracks.append([self.tag_art[a], trk[1]])

        return(r_tracks)

    def tag_tracks(self):
        '''
        Match collection tracks to Beatport track ID
        '''
        self.tag_trk = {}
        self.no_trk = []

        trks = self._recode_tracks()

        self._setup_progress_bar(len(trks))

        for i, trk in enumerate(trks):

            self._update_progress_bar(i)

            qry = self.bprt.track_search_w_artist_id(trk[1], trk[0])

            # sleep(1)

            found = 0
            i = 0

            while (found == 0) and (i < len(qry)):

                if qry[i].has_key('artists'):
                    j = 0

                    while (found == 0) and (j < len(qry[i]['artists'])):
                        a_id = qry[i]['artists'][j]['id']

                        if a_id == trk[0]:
                            self.tag_trk[qry[i]['id']] = (a_id,
                                                          qry[i]['name'],
                                                          trk[1])
                            found = 1

                        j += 1
                i += 1

            if found == 0:

                self.no_trk.append(trk)

        self._escape_progress_bar()

        return

    def track_playcount(self, fname):
        '''
        Read XML file and match track ID with collection play count and
        date added to collection
        '''
        self.play_count = {}

        with open(fname, 'r') as fd:
            doc = xmltodict.parse(fd.read())

        for key, val in self.tag_trk.iteritems():
            for track in doc['DJ_PLAYLISTS']['COLLECTION']['TRACK']:
                # import pdb; pdb.set_trace()
                tmp_name = track['@Name'].lower()\
                                         .replace(' (original mix)','')\
                                         .replace(' - original mix','')\
                                         .replace(' 320','')

                if 'feat' in val[1]:
                    loc = val[1].find('feat')
                    val_name = val[1].lower()[:loc - 2]
                else:
                    val_name = val[1].lower()

                if (val_name in tmp_name) and (self.art_tag[val[0]] in track['@Artist'].lower()):
                    self.play_count[key] = (track['@PlayCount'], track['@DateAdded'])

        return


    def save_artists(self):
        '''
        Store list of artists from collection in Postgres
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()

        cur.execute('DROP TABLE IF EXISTS my_artist')
        cur.execute('''CREATE TABLE my_artist (id INTEGER PRIMARY KEY)''')
        conn.commit()

        for key, val in self.tag_art.iteritems():
            cur.execute('INSERT INTO my_artist (id) VALUES (%s)', [val])

        conn.commit()

        cur.close()
        conn.close()
        return

    def save_tracks(self):
        '''
        Store list of artists from collection in Postgres
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()

        cur.execute('DROP TABLE IF EXISTS my_tracks')
        cur.execute('''CREATE TABLE my_tracks (id INTEGER PRIMARY KEY,
                                               artist_id INTEGER,
                                               bprt_name TEXT,
                                               col_name TEXT)''')
        conn.commit()

        for key, val in self.tag_trk.iteritems():
            cur.execute('''INSERT INTO my_tracks (id,
                                                  artist_id,
                                                  bprt_name,
                                                  col_name)
                                                  VALUES (%s, %s, %s, %s);''',
                                                  (key, val[0], val[1], val[2]))

        conn.commit()

        cur.close()
        conn.close()
        return

    def save_playcount(self):
        '''
        Store play count and date added
        for each track from collection in Postgres
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()

        cur.execute('DROP TABLE IF EXISTS my_playcount')
        cur.execute('''CREATE TABLE my_playcount (id INTEGER PRIMARY KEY,
                                                  playcount INTEGER,
                                                  DateAdded DATE)''')
        conn.commit()

        for key, val in self.play_count.iteritems():
            cur.execute('''INSERT INTO my_playcount (id,
                                                     playcount,
                                                     DateAdded)
                                                  VALUES (%s, %s, %s);''',
                                                  (key, val[0], val[1]))

        conn.commit()

        cur.close()
        conn.close()
        return


if __name__ == '__main__':
    now = time()

    '''
    TO DO; Rekordbox playlist doesn't contain track details
    such as Date Added or Play Count. Rekordbox can export an XML file which
    contains that information. collectionlister should be refactored to use
    the XML so all track data can be harmonized at once instead of two passes.
    '''
    tracks = collectionlister('../data/my_collection.m3u8')
    tracks.build()

    bprt = beatport('/Users/danius/galvanize/API/mykeys.yaml')
    bprt.initialize()

    ritchey = collectiontagger(bprt, tracks.collection)
    ritchey.tag_artists()
    ritchey.save_artists()

    ritchey.tag_tracks()
    ritchey.save_tracks()

    ritchey.track_playcount('/Users/danius/Documents/Github/beatnet/data/xml_collection_020817.xml')
    ritchey.save_playcount()

    later = time()

    t = (later - now) * (1/60)

    print('Collection tagging took {} minutes'.format(t))

import sys, curses

import psycopg2 as pg2
import cPickle as pickle

from beatport_api import beatport
from time import time

class collectionlister(object):
    '''
    Class to build track list from M3U8 generated by Rekordbox
    '''

    def __init__(self, fname):
        self.filename = fname

    def read_file(self):
        '''
        Read lines of file and store
        '''
        self.lines = []
        string = ''
        with open(self.filename, 'r') as f:

            for line in f.read():

                string += line

                if line == '\n':
                    self.lines.append(string)
                    string = ''

        return

    def read_tracks(self):
        '''
        Transform file into better format
        '''
        soln = []

        for track in self.lines:
            if track[0:7] == '#EXTINF':
                pos = track.find(',') + 1
                soln.append(track[pos:])

        self.tracks = self.strip_return(soln)

        return

    def strip_return(self, tracks):
        '''
        Remove the carriage return from last track
        '''

        tracks = [track.replace('\r\n','') for track in tracks]

        return(tracks)

    def build(self):
        '''
        Build track list and return list
        '''
        self.collection = []

        self.read_file()

        self.read_tracks()

        for track in self.tracks:
            trk = track.split(' - ')
            self.collection.append(trk)

        return

class collectiontagger(object):

    def __init__(self, beatport, my_collection):
        self.bprt = beatport
        self.my_col = my_collection

    def _setup_progress_bar(self, num):
        curses.initscr()
        curses.curs_set(0)

        sentence = 'Track {} of {} complete.' \
                     .format(' '*len(str(num)), str(num))

        sys.stdout.write(sentence)
        sys.stdout.flush()

        sys.stdout.write('\b' * (len(sentence) - 6))

        return

    def _update_progress_bar(self, curr):
        pg = str(curr)

        sys.stdout.write(pg)
        sys.stdout.flush()
        sys.stdout.write('\b' * len(pg))

        return

    def _escape_progress_bar(self):
        sys.stdout.write('\n')
        curses.curs_set(1)
        curses.reset_shell_mode()
        return

    def _convert_raw_artist(self, artists):

        artists = artists.replace(', ','*') \
                         .replace(' feat ','*') \
                         .replace(' feat. ','*') \
                         .replace(' ft ','*') \
                         .replace(' ft. ','*') \
                         .lower() \
                         .split('*')
        soln = []
        for a in artists:
            soln.append(a)
            if ' & ' in a:
                soln.extend(a.split(' & '))

        return(soln)

    def _artist_set(self, tracks):
        '''
        Clean up artist names and build set
        '''
        artists = set()

        for track in tracks:

            track = self._convert_raw_artist(track[0])

            for art in track:

                artists.add(art)

        return(artists)

    def _beatport_artists(self):
        '''
        Fetch all artists and ids from Postgres
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()

        cur.execute('SELECT * FROM bprt_artist;')
        data = cur.fetchall()

        cur.close()
        conn.close()

        btprt_artist = {}
        for val in data:
            btprt_artist[val[1]] = val[0]

        return(btprt_artist)

    def tag_artists(self):
        '''
        Match collection artist to Beatport artist ID
        '''
        my_art = self._artist_set(self.my_col)
        bprt_art = self._beatport_artists()

        self.tag_art = {}
        for val in my_art:
            if bprt_art.has_key(val):
                self.tag_art[val] = bprt_art[val]

        return

    def _recode_tracks(self):
        '''
        Recode collection into artist id and track name
        '''
        r_tracks = []
        for trk in self.my_col:
            arts = self._convert_raw_artist(trk[0])

            for a in arts:
                if self.tag_art.has_key(a):
                    r_tracks.append([self.tag_art[a], trk[1]])

        return(r_tracks)

    def tag_tracks(self):
        '''
        Match collection tracks to Beatport track ID
        '''
        self.tag_trk = {}
        self.no_trk = []

        trks = self._recode_tracks()

        self._setup_progress_bar(len(trks))

        for i, trk in enumerate(trks):

            self._update_progress_bar(i)

            qry = self.bprt.track_search_w_artist_id(trk[1], trk[0])

            found = 0
            i = 0

            while (found == 0) and (i < len(qry)):

                if qry[i].has_key('artists'):
                    j = 0

                    while (found == 0) and (j < len(qry[i]['artists'])):
                        a_id = qry[i]['artists'][j]['id']

                        if a_id == trk[0]:
                            self.tag_trk[qry[i]['id']] = (a_id, qry[i]['name'])
                            found = 1

                        j += 1
                i += 1

            if found == 0:

                self.no_trk.append(trk)

        self._escape_progress_bar()

        return

    def save_artists(self):
        '''
        Store list of artists from collection in Postgres
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()

        cur.execute('DROP TABLE IF EXISTS my_artist')
        cur.execute('''CREATE TABLE my_artist (id INTEGER PRIMARY KEY)''')
        conn.commit()

        for key, val in self.tag_art.iteritems():
            cur.execute('INSERT INTO my_artist (id) VALUES (%s)', [val])

        conn.commit()

        cur.close()
        conn.close()
        return

    def save_tracks(self):
        '''
        Store list of artists from collection in Postgres
        '''
        conn = pg2.connect('dbname=beatport user=danius')
        cur = conn.cursor()

        cur.execute('DROP TABLE IF EXISTS my_tracks')
        cur.execute('''CREATE TABLE my_tracks (id INTEGER PRIMARY KEY,
                                               artist_id INTEGER,
                                               name TEXT)''')
        conn.commit()

        for key, val in self.tag_trk.iteritems():
            cur.execute('''INSERT INTO my_tracks (id,
                                                  artist_id,
                                                  name)
                                                  VALUES (%s, %s, %s);''',
                                                  (key, val[0], val[1]))

        conn.commit()

        cur.close()
        conn.close()
        return

if __name__ == '__main__':
    now = time()

    tracks = collectionlister('../data/my_collection.m3u8')
    tracks.build()

    bprt = beatport('/Users/danius/galvanize/API/mykeys.yaml')
    bprt.initialize()

    ritchey = collectiontagger(bprt, tracks.collection)
    ritchey.tag_artists()
    ritchey.save_artists()

    ritchey.tag_tracks()

    with open('ritchey.pkl', 'w') as f:
        pickle.dump(ritchey, f)

    ritchey.save_tracks()

    later = time()

    t = (later - now) * (1/60)

    print('Collection tagging took {} minutes'.format(t))
